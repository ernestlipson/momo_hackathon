# Comprehensive Copilot Instructions for Mobile Money Fraud Detection Platform

## Overview

This document contains comprehensive instructions for AI assistance on the Ghana Mobile Money Fraud Detection Platform built with Flutter and AWS. These instructions enforce a security-first, plan-then-code workflow optimized for mobile fraud detection applications.

---

## Project Overview

This is a Flutter project using GetX for state management, routing, and dependency injection, following the GetX pattern architecture generated by get_cli. The platform focuses on detecting and preventing mobile money fraud using AWS Nova multimodal analysis and advanced security measures.

### Technology Stack

- **Frontend**: Flutter 3.9+, Dart
- **State Management**: GetX
- **Backend**: NestJS API
- **Cloud Services**: AWS Nova, AWS Fraud Detector
- **Security**: Biometric authentication, encryption, PCI DSS compliance

---

## Development Workflow: Plan-Then-Code

When asked for help with any task, follow this strict workflow:

### Phase 1 — Planning (No Code Yet)

Produce a concise but detailed plan that includes:

#### Core Planning Elements

- **Goal and scope** - What specific feature/fix and its boundaries
- **Assumptions and constraints** - Technical limitations, business rules, regulatory requirements
- **Risks and unknowns** - Security vulnerabilities, performance impacts, user experience concerns
- **Deliverables** - Dart files, widgets, APIs, tests, documentation, migrations

#### Flutter/Mobile Specific Considerations

- **State management** - GetX controllers, reactive patterns, dependency injection
- **Widget architecture** - UI components, responsive design, accessibility compliance
- **Navigation flow** - Route management, deep linking, back button handling
- **Performance** - Build optimization, memory usage, battery impact, startup time
- **Platform compatibility** - iOS/Android differences, device capabilities, OS versions

#### Security & Privacy (Critical for Fraud Detection)

- **Data protection** - Encryption, secure storage, PII handling, GDPR/local compliance
- **Authentication** - Biometric auth, session management, token security
- **API security** - Request signing, rate limiting, input validation
- **Fraud prevention** - Anti-tampering, jailbreak detection, secure communication

#### Technical Architecture

- **Proposed approach** - High-level steps with sub-steps and GetX patterns
- **Affected files/components** - Controllers, views, models, services, routes
- **API integration** - AWS services, error handling, offline capability
- **Database/storage** - Local storage strategy, caching, sync mechanisms
- **Alternatives considered** - With tradeoffs for performance, security, maintainability

#### Quality Assurance

- **Test plan** - Unit tests (controllers/models), widget tests (UI), integration tests (E2E flows)
- **Acceptance criteria** - User stories, edge cases, error scenarios
- **Accessibility** - Screen reader support, keyboard navigation, color contrast
- **Localization** - Multi-language support, RTL layouts, cultural considerations

#### Deployment & Monitoring

- **Observability/metrics** - Crash reporting, performance monitoring, fraud detection metrics
- **Rollout strategy** - Staged deployment, feature flags, rollback plans
- **Migration steps** - Data migration, backward compatibility, user communication
- **Effort estimate** - Development time, testing time, review cycles, dependencies

**Then ask**: "Do you want me to proceed with implementation based on this plan? Reply 'yes' to proceed or suggest changes."

### Phase 2 — Implementation (Only After Approval)

#### Development Guidelines

- **Follow GetX patterns** - Use GetxController for state, GetView for UI, proper dependency injection
- **Security first** - Validate all inputs, encrypt sensitive data, follow OWASP mobile guidelines
- **Implement step-by-step** - Following the approved plan with clear references to plan items
- **Keep changes atomic** - Small, verifiable commits with comprehensive tests
- **Flutter best practices** - Widget composition, const constructors, efficient rebuilds
- **Code organization** - Clear separation: controllers, views, models, services, routes

#### Quality Checks

- **Test coverage** - Unit tests for business logic, widget tests for UI, integration for user flows
- **Performance validation** - Check build times, app size, memory usage, startup performance
- **Security review** - Validate authentication flows, API security, data protection measures
- **Accessibility audit** - Screen reader compatibility, keyboard navigation, semantic labels
- **Cross-platform testing** - iOS and Android functionality, UI consistency, platform-specific features

#### Change Management

- **Reference plan items** - Each change should map to specific planning elements
- **Pause for scope changes** - If new information changes the plan, request updated approval
- **Document decisions** - Architecture choices, security considerations, performance trade-offs
- **Review integration points** - AWS services, third-party APIs, platform-specific code

---

## Architecture Pattern - GetX Pattern

### MVC Architecture

- **Model**: Data layer (models, providers, repositories)
- **View**: UI components (widgets, screens)
- **Controller**: Business logic and state management
- **Separation of Concerns**: Business logic, UI, and data are completely decoupled
- **Reactive Programming**: Using GetX observables (.obs) for state management
- **Dependency Injection**: Using GetX bindings for dependency management

### Project Structure

```
lib/
├── app/
│   ├── data/                    # Data layer (models, providers, repositories)
│   ├── modules/                 # Feature modules
│   │   └── [module_name]/
│   │       ├── bindings/        # Dependency injection
│   │       ├── controllers/     # Business logic
│   │       └── views/           # UI components
│   └── routes/                  # Navigation configuration
│       ├── app_pages.dart       # Route definitions
│       └── app_routes.dart      # Route constants
└── main.dart                    # App entry point
```

---

## Code Guidelines & Best Practices

### 1. Controller Implementation

```dart
class ExampleController extends GetxController {
  // Observable variables
  final count = 0.obs;
  final isLoading = false.obs;
  final user = Rxn<User>(); // Nullable observable
  
  // Getters for computed values
  String get formattedCount => 'Count: ${count.value}';
  
  // Lifecycle methods
  @override
  void onInit() {
    super.onInit();
    // Initialize data, API calls, listeners
  }
  
  @override
  void onReady() {
    super.onReady();
    // Called after widget build is complete
  }
  
  @override
  void onClose() {
    super.onClose();
    // Cleanup resources
  }
  
  // Business logic methods
  void increment() => count.value++;
  
  Future<void> fetchData() async {
    try {
      isLoading.value = true;
      // API call
    } catch (e) {
      // Error handling
    } finally {
      isLoading.value = false;
    }
  }
}
```

### 2. View Implementation

```dart
class ExampleView extends GetView<ExampleController> {
  const ExampleView({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Example')),
      body: Column(
        children: [
          // Use Obx for reactive updates
          Obx(() => Text('Count: ${controller.count}')),
          
          // Use GetBuilder for non-reactive updates
          GetBuilder<ExampleController>(
            builder: (controller) => Text('Static: ${controller.count}'),
          ),
          
          ElevatedButton(
            onPressed: controller.increment,
            child: const Text('Increment'),
          ),
        ],
      ),
    );
  }
}
```

### 3. Binding Implementation

```dart
class ExampleBinding extends Bindings {
  @override
  void dependencies() {
    // Lazy loading (created when first used)
    Get.lazyPut<ExampleController>(() => ExampleController());
    
    // Immediate creation
    Get.put<ExampleService>(ExampleService());
    
    // Singleton pattern
    Get.putAsync<ApiService>(() => ApiService.init());
  }
}
```

### 4. Route Management

```dart
// In app_routes.dart
abstract class Routes {
  static const EXAMPLE = _Paths.EXAMPLE;
}

abstract class _Paths {
  static const EXAMPLE = '/example';
}

// In app_pages.dart
GetPage(
  name: _Paths.EXAMPLE,
  page: () => const ExampleView(),
  binding: ExampleBinding(),
  middlewares: [AuthMiddleware()], // Optional
),
```

### 5. Navigation Patterns

```dart
// Navigate to named route
Get.toNamed(Routes.EXAMPLE);

// Navigate with arguments
Get.toNamed(Routes.EXAMPLE, arguments: {'id': 123});

// Navigate and replace current route
Get.offNamed(Routes.EXAMPLE);

// Navigate and clear stack
Get.offAllNamed(Routes.HOME);

// Go back
Get.back();

// Go back with result
Get.back(result: 'success');
```

---

## State Management Patterns

### Observable Types

- `RxString`, `RxInt`, `RxDouble`, `RxBool` for primitives
- `RxList<T>` for lists
- `RxMap<K,V>` for maps
- `Rx<T>` for custom objects
- `Rxn<T>` for nullable objects

### Reactive Updates

```dart
// Use Obx for simple reactive widgets
Obx(() => Text(controller.message.value))

// Use GetX for complex reactive widgets with error handling
GetX<ExampleController>(
  builder: (controller) => Text(controller.message.value),
  init: ExampleController(),
)
```

---

## Dependency Injection Patterns

### Service Classes

```dart
class ApiService extends GetxService {
  // Services extend GetxService for singleton behavior
  
  Future<void> onInit() async {
    super.onInit();
    // Initialize service
  }
}
```

### Repository Pattern

```dart
abstract class ExampleRepository {
  Future<List<Item>> getItems();
}

class ExampleRepositoryImpl implements ExampleRepository {
  final ApiService _apiService = Get.find();
  
  @override
  Future<List<Item>> getItems() async {
    return await _apiService.fetchItems();
  }
}
```

---

## Mobile Money Fraud Detection Specific Guidelines

### Security Priorities

1. **Data Encryption** - All PII and financial data encrypted at rest and in transit (AES-256)
2. **API Security** - Request signing, rate limiting, input sanitization
3. **Authentication** - Multi-factor auth, biometric verification, session management
4. **Fraud Prevention** - Real-time transaction monitoring, pattern analysis, user behavior
5. **Compliance** - PCI DSS considerations, OWASP mobile security guidelines

### Performance Requirements

1. **Response Time** - Fraud detection API calls <2s, UI interactions <100ms
2. **Offline Capability** - Core features work without internet, sync when connected
3. **Battery Optimization** - Background processing, efficient network usage
4. **Memory Management** - Handle large transaction datasets, proper disposal
5. **App Targets** - Cold start <3s, bundle size <50MB

### User Experience Standards

1. **Accessibility** - WCAG 2.1 AA compliance, screen reader support
2. **Localization** - Support for Ghanaian languages, currency formatting
3. **Progressive Disclosure** - Complex security features with clear explanations
4. **Error Handling** - Clear, actionable error messages, graceful degradation

---

## Common Patterns & Commands

### Creating New Modules

Use get_cli commands for consistency:

```bash
# Create new module
get create page:example

# Create controller only
get create controller:example on example

# Create binding only
get create binding:example on example
```

### Error Handling

```dart
// In controllers
void handleError(dynamic error) {
  if (error is ApiException) {
    Get.snackbar('Error', error.message);
  } else {
    Get.snackbar('Error', 'Something went wrong');
  }
}
```

### Loading States

```dart
// Standard loading pattern
Future<void> performAction() async {
  try {
    isLoading.value = true;
    await someAsyncOperation();
  } catch (e) {
    handleError(e);
  } finally {
    isLoading.value = false;
  }
}
```

### Form Handling

```dart
// In controller
final formKey = GlobalKey<FormState>();
final emailController = TextEditingController();
final passwordController = TextEditingController();

void submitForm() {
  if (formKey.currentState!.validate()) {
    // Process form
  }
}

@override
void onClose() {
  emailController.dispose();
  passwordController.dispose();
  super.onClose();
}
```

---

## Testing Guidelines

- Test controllers in isolation
- Mock dependencies using GetX dependency injection
- Use `Get.testMode = true` for navigation testing
- Comprehensive coverage: unit tests (controllers/models), widget tests (UI), integration tests (E2E flows)
- Security testing: authentication flows, API security, data protection measures
- Performance testing: build times, app size, memory usage, startup performance

---

## Performance Best Practices

- Use `Get.lazyPut()` for controllers that aren't immediately needed
- Dispose resources in `onClose()`
- Use `ever()`, `once()`, `debounce()` for reactive programming
- Avoid creating observables in build methods
- Efficient network usage and battery optimization
- Proper memory management for large datasets

---

## Code Style Guidelines

- Use descriptive names for controllers, views, and bindings
- Keep controllers focused on single responsibilities
- Extract complex UI components into separate widgets
- Use const constructors where possible
- Follow Dart/Flutter naming conventions
- Maintain clear separation of concerns

---

## Common GetX Utilities

- `Get.snackbar()` for notifications
- `Get.dialog()` for dialogs
- `Get.bottomSheet()` for bottom sheets
- `Get.defaultDialog()` for simple dialogs
- `Get.theme` for theme access
- `Get.locale` for localization

---

## Module Structure Template

When creating new features, maintain this structure:

```
modules/
└── feature_name/
    ├── bindings/
    │   └── feature_binding.dart
    ├── controllers/
    │   └── feature_controller.dart
    ├── views/
    │   ├── feature_view.dart
    │   └── widgets/
    │       └── feature_widget.dart
    └── models/          # If needed
        └── feature_model.dart
```

---

## Usage Examples

### Feature Development

```
task="Implement biometric authentication for transaction verification" 
constraints="Must work offline, comply with PCI DSS" 
scope="Authentication module and fraud detection"
platform="iOS and Android - use platform biometric APIs"
```

### Bug Fixes

```
task="Fix GetX controller memory leak in transaction history" 
constraints="Zero downtime, maintain user session" 
scope="Transaction controller and related views"
platform="Both platforms affected"
```

### Security Enhancements

```
task="Add SMS fraud detection using AWS Nova multimodal analysis" 
constraints="Real-time processing, data privacy compliance" 
scope="SMS processing service and fraud detection API"
platform="Android SMS permissions, iOS message filtering"
```

### Performance Optimization

```
task="Optimize app startup time and reduce bundle size" 
constraints="Target <3s cold start, <50MB app size" 
scope="App initialization, lazy loading, asset optimization"
platform="Platform-specific optimization strategies"
```

---

## Automatic Behaviors

Every AI assistance interaction will automatically:

✅ **Follow plan-then-code workflow** - No coding without approved plans
✅ **Prioritize security** - Encryption, validation, authentication first
✅ **Use GetX patterns** - Proper state management and dependency injection  
✅ **Consider mobile constraints** - Performance, battery, accessibility
✅ **Include comprehensive testing** - Unit, widget, and integration tests
✅ **Document architectural decisions** - Clear explanations for choices
✅ **Ensure cross-platform compatibility** - iOS and Android considerations
✅ **Implement fraud detection best practices** - Real-time monitoring, pattern analysis

---

## Remember

Follow the GetX pattern principles of **PRODUCTIVITY**, **PERFORMANCE**, and **ORGANIZATION** in all implementations while maintaining the highest security standards for fraud detection applications.

Always prioritize:

1. **Security** - Protect user data and prevent fraud
2. **Performance** - Fast, responsive mobile experience
3. **Accessibility** - Inclusive design for all users
4. **Maintainability** - Clean, testable, well-documented code
5. **User Experience** - Intuitive, reliable fraud prevention tools
