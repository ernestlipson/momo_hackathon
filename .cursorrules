# GetX Flutter Project - Copilot Instructions

## Project Overview
This is a Flutter project using GetX for state management, routing, and dependency injection, following the GetX pattern architecture generated by get_cli.

## Architecture Pattern - GetX Pattern
- **MVC Architecture**: Model-View-Controller pattern with GetX
- **Separation of Concerns**: Business logic, UI, and data are completely decoupled
- **Reactive Programming**: Using GetX observables (.obs) for state management
- **Dependency Injection**: Using GetX bindings for dependency management

## Project Structure
```
lib/
├── app/
│   ├── data/                    # Data layer (models, providers, repositories)
│   ├── modules/                 # Feature modules
│   │   └── [module_name]/
│   │       ├── bindings/        # Dependency injection
│   │       ├── controllers/     # Business logic
│   │       └── views/           # UI components
│   └── routes/                  # Navigation configuration
│       ├── app_pages.dart       # Route definitions
│       └── app_routes.dart      # Route constants
└── main.dart                    # App entry point
```

## Code Guidelines & Best Practices

### 1. Controller Implementation
```dart
class ExampleController extends GetxController {
  // Observable variables
  final count = 0.obs;
  final isLoading = false.obs;
  final user = Rxn<User>(); // Nullable observable
  
  // Getters for computed values
  String get formattedCount => 'Count: ${count.value}';
  
  // Lifecycle methods
  @override
  void onInit() {
    super.onInit();
    // Initialize data, API calls, listeners
  }
  
  @override
  void onReady() {
    super.onReady();
    // Called after widget build is complete
  }
  
  @override
  void onClose() {
    super.onClose();
    // Cleanup resources
  }
  
  // Business logic methods
  void increment() => count.value++;
  
  Future<void> fetchData() async {
    try {
      isLoading.value = true;
      // API call
    } catch (e) {
      // Error handling
    } finally {
      isLoading.value = false;
    }
  }
}
```

### 2. View Implementation
```dart
class ExampleView extends GetView<ExampleController> {
  const ExampleView({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Example')),
      body: Column(
        children: [
          // Use Obx for reactive updates
          Obx(() => Text('Count: ${controller.count}')),
          
          // Use GetBuilder for non-reactive updates
          GetBuilder<ExampleController>(
            builder: (controller) => Text('Static: ${controller.count}'),
          ),
          
          ElevatedButton(
            onPressed: controller.increment,
            child: const Text('Increment'),
          ),
        ],
      ),
    );
  }
}
```

### 3. Binding Implementation
```dart
class ExampleBinding extends Bindings {
  @override
  void dependencies() {
    // Lazy loading (created when first used)
    Get.lazyPut<ExampleController>(() => ExampleController());
    
    // Immediate creation
    Get.put<ExampleService>(ExampleService());
    
    // Singleton pattern
    Get.putAsync<ApiService>(() => ApiService.init());
  }
}
```

### 4. Route Management
```dart
// In app_routes.dart
abstract class Routes {
  static const EXAMPLE = _Paths.EXAMPLE;
}

abstract class _Paths {
  static const EXAMPLE = '/example';
}

// In app_pages.dart
GetPage(
  name: _Paths.EXAMPLE,
  page: () => const ExampleView(),
  binding: ExampleBinding(),
  middlewares: [AuthMiddleware()], // Optional
),
```

### 5. Navigation Patterns
```dart
// Navigate to named route
Get.toNamed(Routes.EXAMPLE);

// Navigate with arguments
Get.toNamed(Routes.EXAMPLE, arguments: {'id': 123});

// Navigate and replace current route
Get.offNamed(Routes.EXAMPLE);

// Navigate and clear stack
Get.offAllNamed(Routes.HOME);

// Go back
Get.back();

// Go back with result
Get.back(result: 'success');
```

## State Management Patterns

### Observable Types
- `RxString`, `RxInt`, `RxDouble`, `RxBool` for primitives
- `RxList<T>` for lists
- `RxMap<K,V>` for maps
- `Rx<T>` for custom objects
- `Rxn<T>` for nullable objects

### Reactive Updates
```dart
// Use Obx for simple reactive widgets
Obx(() => Text(controller.message.value))

// Use GetX for complex reactive widgets with error handling
GetX<ExampleController>(
  builder: (controller) => Text(controller.message.value),
  init: ExampleController(),
)
```

## Dependency Injection Patterns

### Service Classes
```dart
class ApiService extends GetxService {
  // Services extend GetxService for singleton behavior
  
  Future<void> onInit() async {
    super.onInit();
    // Initialize service
  }
}
```

### Repository Pattern
```dart
abstract class ExampleRepository {
  Future<List<Item>> getItems();
}

class ExampleRepositoryImpl implements ExampleRepository {
  final ApiService _apiService = Get.find();
  
  @override
  Future<List<Item>> getItems() async {
    return await _apiService.fetchItems();
  }
}
```

## Common Patterns & Commands

### Creating New Modules
Use get_cli commands for consistency:
```bash
# Create new module
get create page:example

# Create controller only
get create controller:example on example

# Create binding only
get create binding:example on example
```

### Error Handling
```dart
// In controllers
void handleError(dynamic error) {
  if (error is ApiException) {
    Get.snackbar('Error', error.message);
  } else {
    Get.snackbar('Error', 'Something went wrong');
  }
}
```

### Loading States
```dart
// Standard loading pattern
Future<void> performAction() async {
  try {
    isLoading.value = true;
    await someAsyncOperation();
  } catch (e) {
    handleError(e);
  } finally {
    isLoading.value = false;
  }
}
```

### Form Handling
```dart
// In controller
final formKey = GlobalKey<FormState>();
final emailController = TextEditingController();
final passwordController = TextEditingController();

void submitForm() {
  if (formKey.currentState!.validate()) {
    // Process form
  }
}

@override
void onClose() {
  emailController.dispose();
  passwordController.dispose();
  super.onClose();
}
```

## Testing Guidelines
- Test controllers in isolation
- Mock dependencies using GetX dependency injection
- Use `Get.testMode = true` for navigation testing

## Performance Best Practices
- Use `Get.lazyPut()` for controllers that aren't immediately needed
- Dispose resources in `onClose()`
- Use `ever()`, `once()`, `debounce()` for reactive programming
- Avoid creating observables in build methods

## Code Style
- Use descriptive names for controllers, views, and bindings
- Keep controllers focused on single responsibilities
- Extract complex UI components into separate widgets
- Use const constructors where possible
- Follow Dart/Flutter naming conventions

## Common GetX Utilities
- `Get.snackbar()` for notifications
- `Get.dialog()` for dialogs
- `Get.bottomSheet()` for bottom sheets
- `Get.defaultDialog()` for simple dialogs
- `Get.theme` for theme access
- `Get.locale` for localization

## Module Structure Example
When creating new features, maintain this structure:
```
modules/
└── feature_name/
    ├── bindings/
    │   └── feature_binding.dart
    ├── controllers/
    │   └── feature_controller.dart
    ├── views/
    │   ├── feature_view.dart
    │   └── widgets/
    │       └── feature_widget.dart
    └── models/          # If needed
        └── feature_model.dart
```

Remember: Follow the GetX pattern principles of PRODUCTIVITY, PERFORMANCE, and ORGANIZATION in all implementations.
